[{"categories":["Golang"],"contents":"1. 值传递还是引用传递 Go函数的参数始终按值传递。\n当结构体（或数组）类型的变量传递给函数时，整个结构都会被复制。\n如果传递的是结构体指针，则复制的是指针，占8字节内存大小（64位系统），它指向的结构体不会被复制。\n这是否意味着传递结构体指针会更好吗？\n传递指针的结构体会被放置在堆内存中，而不是栈中。\n如果动态分配的结构体占用多于直接传递，那么将它复制到栈中会更快：\npackage test import ( \u0026#34;os\u0026#34; \u0026#34;runtime/trace\u0026#34; \u0026#34;testing\u0026#34; ) type S struct { a, b, c int64 d, e, f string g, h, i float64 } func byValue() S { return S{ a: 1, b: 1, c: 1, d: \u0026#34;foo\u0026#34;, e: \u0026#34;bar\u0026#34;, f: \u0026#34;baz\u0026#34;, g: 1.0, h: 1.0, i: 1.0, } } func byReference() *S { return \u0026amp;S{ a: 1, b: 1, c: 1, d: \u0026#34;foo\u0026#34;, e: \u0026#34;bar\u0026#34;, f: \u0026#34;baz\u0026#34;, g: 1.0, h: 1.0, i: 1.0, } } func BenchmarkByValue(b *testing.B) { var s S f, err := os.Create(\u0026#34;stack.out\u0026#34;) if err != nil { b.Fatal(err) } defer f.Close() err = trace.Start(f) if err != nil { b.Fatal(err) } for i := 0; i \u0026lt; b.N; i++ { s = byValue() } trace.Stop() b.StopTimer() _ = s } func BenchmarkByReference(b *testing.B) { var s *S f, err := os.Create(\u0026#34;heap.out\u0026#34;) if err != nil { b.Fatal(err) } defer f.Close() err = trace.Start(f) if err != nil { b.Fatal(err) } for i := 0; i \u0026lt; b.N; i++ { s = byReference() } trace.Stop() b.StopTimer() _ = s } 让我们运行benchmarks：\nBenchmarkByValue-6 353830330\t3.368 ns/op\t0 B/op\t0 allocs/op\nBenchmarkByReference-6 21056649\t53.82 ns/op\t96 B/op\t1 allocs/op\n可以看出，当结构体通过值传递，不涉及动态分配或垃圾回收器，会更快。\n为了理解原因，让我们看一下trace生成的图表。\nBenchmarkByValue: BenchmarkByReference: 第一张图非常简单。由于没有使用堆，因此没有垃圾收集器。\n对于第二张图，指针的使用迫使go编译器将变量逃逸到堆上，并且给垃圾收集器施加压力。\n总之，不要假设值传递会很慢，如果关注性能，可以使用go profiler。\n2. 继承 重新定义 VS 继承类型\nGo类型系统不像C++或Java那样面向对象。Go无法真正继承结构体或接口，但可以将它们嵌套在一起以创建更复杂的结构体或接口。\nThere is an important way in which embedding differs from subclassing. When we embed a type, the methods of that type become methods of the outer type, but when they\u0026rsquo;re invoked the receiver of the method is the inner type, not the outer one.\nhttps://golang.org/doc/effective_go\n除了嵌入类型之外，Go还允许重新定义类型。重新定义继承类型的字段，但不继承其方法。\npackage main type t1 struct { f1 string } func (t *t1) t1method() { } type t2 struct { t1 } type t3 t1 func main() { var mt1 t1 var mt2 t2 var mt3 t3 // 所有case字段都能继承 _ = mt1.f1 _ = mt2.f1 _ = mt3.f1 // 正常调用 mt1.t1method() mt2.t1method() // mt3.t1method未定义 mt3.t1method() } ","date":"2023-11-01T00:35:31+08:00","permalink":"https://zjx-ERROR.github.io/post/golangtip/","section":"post","tags":null,"title":"Golang技巧"},{"categories":null,"contents":"","date":"2023-10-30T00:02:53+08:00","permalink":"https://zjx-ERROR.github.io/about/","section":"","tags":null,"title":"About Me"}]